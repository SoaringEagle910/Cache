# ICache design
## ICache 时序设计：
- 核心逻辑: 输入: 虚拟地址pc, 输出: 指令inst, 阻塞信号stall. 当stall为低电平时，pc会在时钟上升沿跳到下一个. 
- 时序设计: 两个流水级. 
  - P1: 输入pc, 将pc传给transaddr模块进行地址翻译，传给BRAM进行读取
  - P2: 根据BRAM读出的信号和地址翻译结果判断命中，处理成ICache的输出
- 状态转移逻辑: 
  - 初始或被flush后为IDLE状态. 接受pc = a, 进行P1的处理. 由于p2为空，不给stall, inst给全0表示无效
  - 由于现在还只接受了一个取指请求, 仍为IDLE状态, 相当于流水线向后流动. 假设pc = a 和pc = a+4 均命中, 则对他们进行P2的处理, 不给stall, inst为从BRAM读出来的指令. 同时会开始处理后一条取指请求, 接受到此时pc = a + 8(假设pc正常自增), 进行P1的处理。
  - 由于上一周期处于P2的pc均命中，故当前状态仍为IDLE, 相当于流水线向后流动. 假设pc = a + 8 和pc = a + 12 有未命中的, 故P2的处理中, 给出阻塞信号stall, 开始进行向主存读, 重填cache等操作
- 为什么要这个周期给pc，下个周期才能出结果？——因为读BRAM要一个周期。甚至可以考虑再加一个周期，在BRAM读出后将信号稳定了再输出，从而提高频率。
- 最理想情况是一直命中，此时状态一直是IDLE状态，每个周期接受新的pc，并返回上个周期接受的pc的取指结果inst。即通过流水化，每个取指平均消耗一个周期。

# DCache design
## DCache 时序设计：
- 核心逻辑：输入：有效信号valid, 读写操作op, 虚拟地址virtual_addr等，输出addr_ok, data_ok, rdata。当DCache可以接受新的访存操作时，输出addr_ok为高电平；当读操作完成返回数据rdata有效时，输出data_ok为高电平。
- 时序设计：三个流水级
  - P1: 输入valid, op, virtual_addr等信号，将virtual_addr传给transaddr模块进行地址翻译，传给BRAM进行读取
  - P2: 根据BRAM读出的信号和地址翻译结果判断命中
  - P3: 输出给cpu的信号data_ok, rdata
- 状态转移逻辑
  - 基本同ICache，只不过将输出data_ok和rdata由原来的assign改成上升沿赋值
## DCache 的写操作
- 当接受到写操作时，若不命中，则向主存发起读请求，然后将主存返回数据执行写之后再向BRAM写；若命中则直接向BRAM写。写过的cache行标记为脏，当需要被替换时，标记为脏的cache行会先被写回主存再被替换。

# 重要问题
## 关于VIPT
- 关于VIPT是什么可自行百度，只在这里写写我的理解。VIPT的优点就是用虚拟地址，同时，并行地，进行读取BRAM和地址翻译两个操作——并行提高效率的设计思想。不管是取指还是访存，最终使用的都应该是使用物理地址进行查找，但是虚实地址的低12位相同，所以可以利用这个特点，先用虚拟地址的低12位中的index部分去索引对应的cache行，也就是并不一定要等到地址翻译完再用实地址开始索引cache行。故而VIPT的查询方式由此诞生，接收到虚拟地址就同时的进行读取BRAM和地址翻译两条路，到下个周期两个路线都出结果，就用BRAM中tag信息与地址翻译得到的地址高位进行比较，若相等则命中。是不是十分精妙地衔接上了！
- 设计中可能面对的问题：地址翻译过程如果查询TLB表项可能出关键路径，但如果能做到所有与前后端接口信号被时钟上升沿隔开，也就是给cache划出完整的周期，应该不会太影响整体的频率

# 初学如何设计cache
- 首先明确接口信号，也就是理解cache的功能是什么。知道所有的输入输出信号都是什么意思，也就理解了cache要对信号做什么样的处理，知道了cache如何发挥的缓存的作用。一定要先想清楚这些接口信号的时序，明确了时序再写，debug也会快很多。
- 接着设计cache内部时序，状态转移逻辑。这个时候不需要很全面，实现基本的读写功能就好，其他的什么替换策略、flush信号、cache指令之类的可以后面再加，先考虑多了容易出错还难定位。其实cache可以这么开始写：先针对状态控制写状态机部分，再针对BRAM接口写BRAM的所有输入信号的赋值，再写对外接口信号的赋值，这个过程引申出的变量也对应地赋值，这样一个cache大致就写成了，再根据debug把没有考虑到的方面做修补，其实也不难啦
- 最后将cache完善，适应cpu设计所需进行相应的修改，如加入flush, pause信号等输入信号，根据需求增加输出信号。
- 多参考他人的优秀设计，理解代码背后的设计想法，能学到很多东西的，能少走弯路的。

## 重新审视，给出建议
- 从一开始，所有对外接口的信号做好时序规划，给信号处理的过程完整的周期！！！重要的事再说一遍，给信号处理的过程完整的周期！！！
  - 一定要弄清楚你的对外接口信号给别人是组合接受还是时序接受，你接受的别人的信号是组合接受还是时序接受！这决定了整个流水线设计的怎么样！比如约定好所有输出的信号都要在上升沿接受，或者约定好所有的输出信号都在上升沿赋值，否则流水线就会长成
  |---|---|------||---|---|---
  - 竖线表示时钟上升沿接受信号的地方，相当于切割出流水线。很直观，就因为大家都是先上升沿接受再处理，但是有一个部分接收到的信号被直接assign之类的直接开始处理了，就会导致整个cpu的频率被限制在6个"-"的时间，否则调整一下，
  |---|---|---|---|---|---|---
  - 做了一样多的事，但是cpu的频率可以达到3个"-"的时间，小小的改动，效率能提高一倍！！！
  - 我们的cache设计从最开始就被前端要求得到pc的当周期判断命中，命中的话就组合输出指令，得到取出的指令又直接被拿去做判断之类的——甚至没有给cache一个完整的周期！设计cache时请一定注意！不一定要为了省一小点周期数而复杂化逻辑，影响频率！起码一定必须要做到的是不同模块之间的接口信号要做好规划！cache的所有输入信号如果不是上升沿赋值的就打一拍再用，cache的所有输出信号如果是被组合接受就延迟一拍，上升沿再赋值输出。不同模块之间互不了解对方拿到信号都做了多少处理，一不小心流水线就会长成上面那样！后面再想解决，也由于涉及到模块间的接口，改接口改时序对代码的影响巨大，往往到后面发现的时候就放弃了！往往模块内部想再划出一级流水线比较容易，但是模块之间的接口信号改时序真的很难，debug的时候可能找半天都不知道到底是谁的模块该改。
  - 直到最终的cache设计中，ICache的输入信号flush仍存在组合赋值组合接受，DCache的输出信号addr_ok仍存在组合赋值组合接受，也就是出现了上述丑陋的流水线，关键路径往往就出现在这里了。这样的关键路径难以优化，主要是接口时序设计在此，牵扯到两个模块，后期难以改动。最终关键路径往往就是DCache从BRAM读出信号，处理成addr_ok，addr_ok信号连到后端进行一系列运算得到flush，然后flush又连到前端影响ICache，加TLB后甚至还会影响TLB。一整个前端后端ICacheDCache全部扯进来了，频率没法提上去了啊。